

浅拷贝就是你赋值是赋值的对象的内存地址，两者指向的是同一个堆，相互影响。

深拷贝是指在复制对象或数组时，不仅复制对象本身，还要递归地复制对象的所有子对象，使得新对象与原对象完全独立，互不影响。
目前的话就原生js中，引用类型的深拷贝就只有通过将对象转为字符串，再把字符串转为对象这一方法被广泛使用 `JSON.stringify` `JSON.parse`。


```js

function deepClone(obj, hash = new WeakMap) {

  // 判断是不是非对象 非对象直接返回这个值
  if (!(obj && typeof obj === 'object' && !Array.isArray(obj) && !(obj instanceof RegExp))) return obj

  if (obj instanceof Date) return new Date(obj)

  if (obj instanceof RegExp) return new RegExp(obj)

  if (hash.has(obj)) return hash.get(obj)

  

  let cloneObj = new obj.constructor() // 保留他的原型

  hash.set(obj, cloneObj)

  for (let key in obj) {

    if (obj.hasOwnProperty(key)) {

      cloneObj[key] = deepClone(obj[key], hash)

    }

  }

  return cloneObj

}
```


`WeakMap` 是 JavaScript 中的一个内置对象，它提供了一种存储键值对的方式，其中键必须是对象，而值可以是任意类型的数据。与普通的 `Map` 不同，`WeakMap` 的键是弱引用的，这意味着当一个对象作为键被存储在 `WeakMap` 中时，如果该对象没有其他强引用（即它是唯一引用该对象的地方），那么该对象可以被垃圾回收机制回收。

### 主要特点

1. **弱引用**：`WeakMap` 的键是弱引用的，这意味着如果一个对象仅被 `WeakMap` 的键所引用，那么该对象可以被垃圾回收机制回收。
2. **不可枚举**：`WeakMap` 的内容不能被枚举，因此你不能通过 `for...of` 循环或者 `entries` 方法来获取 `WeakMap` 的所有键值对。
3. **私有存储**：由于 `WeakMap` 的内容不能被枚举，因此它常用于实现私有的数据存储，即其他代码无法轻易访问到这些数据。

### 使用场景

1. **循环引用问题**：在处理具有循环引用的对象时，使用 `WeakMap` 可以避免内存泄漏。
2. **私有数据存储**：当需要为对象添加一些私有的、辅助性的数据时，可以使用 `WeakMap` 来存储这些数据，而不影响对象本身的结构。
3. **缓存机制**：可以用 `WeakMap` 来实现缓存机制，存储一些临时数据，当这些数据不再被使用时，它们会被自动回收。